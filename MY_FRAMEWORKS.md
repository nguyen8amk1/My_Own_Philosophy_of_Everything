MY FRAMEWORKS: 
    THINGS YOU NEED TO KNOW BEFORE CHOOSING AMONG TOOLS (DEDUCE FROM 7DB7W): 
        Learn to make choice given:
            + particular needs  
            + resource at hand 
                understand your options: 
                    -> good, bad options 
                    -> Gets your hand dirty to figure out these questions -> understand the options
                        + What TYPE of TOOL is this ?
                        + What the REASON it created ? 
                            -> the kind of problems they best suited 
                        + How to USE it ? 
                        + What makes it UNIQUE ? 
                            -> understanding the: 
                                + capabilities 
                                + constraints 
                                -> help you pick the right tool for the job 

        The questions to ask is: 
            Should i use this to ... ?
            not Can i ....
            -> the questions is less about the solutions is complete fit with your problem
                but rather it's the best fit given your:
                    + problem space
                    + usage pattern 
                    + available resources 

        Instead of pure dominance of any particular strategy: 
            -> we'll see increasingly SPECIALIZED SOLUTION
            -> each suited for a particular (can be overlapped) SET OF IDEAL PROBLEM SPACE 

        -> @TEST: USE THIS FRAMEWORK TO UNDERSTAND THE NATURE DATA STRUCTURES AND ALGORITHMS 

    GOOD ENOUGH PHILOSOPHY: 
        One of the best(hardest) skills you can ever learn: 
            KNOW WHEN TO STOP: 
                There is a threshold for digging into a rabbit hole 
                But the finding value of the threshold is the problem 
                    -> You can't really found the sweet spot without getting your hands dirty  
                    -> Need a lot of try and error to get it right 
                Digging a knowledge too deep could actually hurt your learning process rather than improving it   
                -> GOOD ENOUGH IS THE STATE THAT YOU DON'T ACTUALLY KNOW ALL THE INS AND OUTS OF THE KNOWLEDGE BUT YOU CAN STILL BENEFIT FROM IT, YOU CAN TRY TO DIG DEEPER AT OTHER TIME  
                -> The threshold best value is the "good enough" 

        Things won't be perfect given the time and technology we currently having 
        Use the thing that is a cut-down version rather than waiting for a perfect to come 
        -> Try to apply the current knowledge 
            (even though it's not perfect match for everything or even well thought out -> know when the stop researching and actually use the knowledge) 
            then refines it afterwards (involve the users in the trade-offs) 

        Questions: WHAT ARE THE PROPERTIES TO CONSIDER ? 

    SYSTEM DESIGN: 
        *High level Design: 
            -> Come up with technologies to solve problems
            Steps: 
                1. Define requirements from the users perspective 
                    -> pick out the most important user's requirements -> technical requirements
                2. Reduce the features to data definition 
                    -> Make abstract/concepts into concrete properties  
                3. Defines endpoints(vd: API) where data can be: 
                    + manipulate 
                    + queried 
                    -> Each for every features 

            -> Goal: create a system that easily:
                + scale 
                + extend  in features 
                when requirements change 

            API Design: 
                Different API have different behaviours: 
                    + continous
                    + prediorically 
                    + rarely called  
                    +...
                    -> Require different PROTOCOL for each behaviour
                -> Try to match the API behaviour with suitable protocol 
                -> Choose correctly could greatly IMPROVE THE PERFORMANCE 

            Choose Database: 
                -> Choose base on pros, cons that benefit the storing requirements 

        *Low level Design:
            -> The clearer the API spec the easier the LLD will be 

            Use composition of 3 diagram: 
                Use case Diagram -> Class Diagram -> Sequential Diagram 

            Use case Diagram: User-System Interaction Diagram 
                -> What the user expect from the system (happy path)

            Class Diagram: 
                specify the:
                    + states
                    + behaviours 
                of objects in the systems
                -> Can create multiple Objects to handle the requirements 

            Sequence Diagram: (I think is the most useful)
                How the user interact with different modules of the system as time pass (relative to time)


    HOW TO LEAD A TEAM: 
        Goal: all members have the same big picture in mind 
        Tools: 
            Diagram:
                Use case diagram
                Class diagram 
                Sequence diagram 
            Rules: 
                vd: rules for file structure,... 

    LEARN HOW TO DECIDE: 
        This is right up the hardest thing i've ever wanted to learn  
        and still can't do it right 
        Really want to know how to be a decisive person ?? 
            -> What i truly want are:
                + Learn to admit the problem with my decision 
                + Learn to actually decide the thing that good on the whole, not just me 
                    (i tend to delay the decision so that i could wait for the timing that beneficial on my part only) -> The reason why i become indecisive -> Selfish TT
                -> These thing should become instince 
        .....

    A MASTER PLAN TO SOLVE PROBLEMS (which should counter my weaknesses in problem solving):
        ....